#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler"
require "open3"
require "set"
require "json"

BASE_REF = ENV["GITHUB_BASE_REF"] || "main"

def gem_review_path
  env_path = ENV["GEM_REVIEW_PATH"]
  return env_path if env_path && !env_path.strip.empty?

  repo_root = `git rev-parse --show-toplevel`.strip
  repo_root = Dir.pwd if repo_root.empty?
  File.join(repo_root, "gem_review.md")
end

def fetch_base_lockfile
  # Ensure we have the base branch locally
  system("git", "fetch", "origin", BASE_REF, exception: true)

  content = git_show_lockfile("origin/#{BASE_REF}")
  if content.strip.empty?
    content = git_show_lockfile(BASE_REF)
  end

  if content.strip.empty?
    warn "Could not read Gemfile.lock from origin/#{BASE_REF} or #{BASE_REF}. Skipping review."
    exit 0
  end

  content
end

def git_show_lockfile(ref)
  stdout, _stderr, status = Open3.capture3("git", "show", "#{ref}:Gemfile.lock")
  status.success? ? stdout : ""
end

def parse_lock(content)
  Bundler::LockfileParser.new(content)
end

def version_tuple(v)
  parts = v.to_s.split(".").map(&:to_i)
  (parts + [0, 0, 0])[0, 3] # ensure [major, minor, patch]
end

def bump_type(old_v, new_v)
  return "added" if old_v.nil?
  return "removed" if new_v.nil?

  o_maj, o_min, o_pat = version_tuple(old_v)
  n_maj, n_min, n_pat = version_tuple(new_v)

  return "major" if n_maj > o_maj
  return "minor" if n_min > o_min
  return "patch" if n_pat > o_pat
  "changed"
end

def risk_level(kind, groups)
  runtime = groups.empty? || (groups & %w[default runtime]).any?
  case kind
  when "major"
    runtime ? "High" : "Medium"
  when "minor"
    runtime ? "Medium" : "Low"
  when "patch"
    "Low"
  else
    "Medium"
  end
end

base_lock_content = fetch_base_lockfile
new_lock_content  = File.read("Gemfile.lock")

base_lock = parse_lock(base_lock_content)
new_lock  = parse_lock(new_lock_content)

base_specs = base_lock.specs.map { |s| [s.name, s.version.to_s] }.to_h
new_specs  = new_lock.specs.map { |s| [s.name, s.version.to_s] }.to_h

base_deps = base_lock.dependencies # name => Bundler::Dependency
new_deps  = new_lock.dependencies

all_gems = Set.new(base_specs.keys) | Set.new(new_specs.keys)

changes = []

all_gems.each do |name|
  old_v = base_specs[name]
  new_v = new_specs[name]
  next if old_v == new_v # unchanged

  kind = bump_type(old_v, new_v)

  # groups from Gemfile (may be nil for transitive deps)
  groups =
    if new_deps[name]
      new_deps[name].groups.map(&:to_s)
    elsif base_deps[name]
      base_deps[name].groups.map(&:to_s)
    else
      [] # purely transitive
    end

  level = risk_level(kind, groups)

  changes << {
    name: name,
    old:  old_v,
    new:  new_v,
    kind: kind,
    groups: (groups.empty? ? ["runtime?"] : groups),
    risk: level
  }
end

if changes.empty?
  begin
    File.write(gem_review_path, "No gem version changes detected between this PR and #{BASE_REF}.")
    unless File.exist?(gem_review_path) && !File.empty?(gem_review_path)
      warn "Failed to write gem_review.md"
      exit 1
    end
    puts "No gem changes."
    exit 0
  rescue StandardError => e
    warn "Error writing gem_review.md: #{e.message}"
    File.write(gem_review_path, "Error generating dependency review: #{e.message}")
    exit 1
  end
end

# Focus the comment on direct deps first, then transitive
direct, transitive = changes.partition { |c| (c[:groups] & ["runtime", "development", "test"]).any? }

markdown = +"## Dependency change summary\n\n"
markdown << "Base branch: `#{BASE_REF}`\n\n"
markdown << "This PR updates the resolved gem set based on changes in `Gemfile` / `Gemfile.lock` (and related gemspec changes, if any).\n\n"

[["Direct dependencies (from Gemfile)", direct],
 ["Transitive / stdlib gems (from Gemfile.lock only)", transitive]].each do |title, list|
  next if list.empty?

  markdown << "### #{title}\n\n"
  markdown << "| Gem | Old | New | Change | Groups | Risk |\n"
  markdown << "|-----|-----|-----|--------|--------|------|\n"
  list.sort_by { |c| c[:name] }.each do |c|
    markdown << "| `#{c[:name]}` | #{c[:old] || '–'} | #{c[:new] || '–'} | #{c[:kind]} | #{c[:groups].join(', ')} | #{c[:risk]} |\n"
  end
  markdown << "\n"
end

markdown << "_Generated by gem_diff GitHub Action._\n"

begin
  File.write(gem_review_path, markdown)
  unless File.exist?(gem_review_path) && !File.empty?(gem_review_path)
    warn "Failed to write gem_review.md"
    exit 1
  end
  puts markdown
rescue StandardError => e
  warn "Error writing gem_review.md: #{e.message}"
  File.write(gem_review_path, "Error generating dependency review: #{e.message}")
  exit 1
end

File.write("gem_changes.json", JSON.pretty_generate(changes))